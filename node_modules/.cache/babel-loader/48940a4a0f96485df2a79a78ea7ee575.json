{"ast":null,"code":"import _slicedToArray from \"/Users/vietle/Documents/personal-project/MyPersonalWebpage/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport assert from './assert';\nimport { log2, clamp } from './math-utils';\nimport { MAX_LATITUDE, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nexport default function fitBounds(options) {\n  var width = options.width,\n    height = options.height,\n    bounds = options.bounds,\n    _options$minExtent = options.minExtent,\n    minExtent = _options$minExtent === void 0 ? 0 : _options$minExtent,\n    _options$maxZoom = options.maxZoom,\n    maxZoom = _options$maxZoom === void 0 ? 24 : _options$maxZoom,\n    _options$offset = options.offset,\n    offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var _bounds = _slicedToArray(bounds, 2),\n    _bounds$ = _slicedToArray(_bounds[0], 2),\n    west = _bounds$[0],\n    south = _bounds$[1],\n    _bounds$2 = _slicedToArray(_bounds[1], 2),\n    east = _bounds$2[0],\n    north = _bounds$2[1];\n  var padding = getPaddingObject(options.padding);\n  var nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  var se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  var size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  var scaleX = targetSize[0] / size[0];\n  var scaleY = targetSize[1] / size[1];\n  var offsetX = (padding.right - padding.left) / 2 / scaleX;\n  var offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  var centerLngLat = worldToLngLat(center);\n  var zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom: zoom\n  };\n}\nfunction getPaddingObject() {\n  var padding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n  assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  return padding;\n}","map":{"version":3,"names":["assert","log2","clamp","MAX_LATITUDE","lngLatToWorld","worldToLngLat","fitBounds","options","width","height","bounds","_options$minExtent","minExtent","_options$maxZoom","maxZoom","_options$offset","offset","_bounds","_slicedToArray","_bounds$","west","south","_bounds$2","east","north","padding","getPaddingObject","nw","se","size","Math","max","abs","targetSize","left","right","top","bottom","scaleX","scaleY","offsetX","offsetY","center","centerLngLat","zoom","min","Number","isFinite","longitude","latitude","arguments","length","undefined"],"sources":["../../src/fit-bounds.ts"],"sourcesContent":["import assert from './assert';\nimport {log2, clamp} from './math-utils';\nimport {MAX_LATITUDE, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\n\n/**\n * Options for fitBounds\n * @param width - viewport width\n * @param height - viewport height\n * @param bounds - [[lon, lat], [lon, lat]]\n * @param minExtent - The width/height of the bounded area will never be smaller than this\n * @param padding - The amount of padding in pixels\n *  to add to the given bounds. Can also be an object with top, bottom, left and right\n *  properties defining the padding.\n * @param options.offset= - The center of the given bounds relative to the map's center,\n */\nexport type FitBoundsOptions = {\n  width: number;\n  height: number;\n  bounds: [[number, number], [number, number]];\n  minExtent?: number; // 0.01 would be about 1000 meters (degree is ~110KM)\n  maxZoom?: number; // ~x4,000,000 => About 10 meter extents\n  // options\n  padding?: number | Padding;\n  offset?: number[];\n};\n\n/**\n * An object describing the padding to add to the bounds.\n * @property top - Padding from top in pixels to add to the given bounds\n * @property bottom - Padding from bottom in pixels to add to the given bounds\n * @property left - Padding from left in pixels to add to the given bounds\n * @property right - Padding from right in pixels to add to the given bounds\n */\nexport type Padding = {\n  top: number;\n  bottom: number;\n  left: number;\n  right: number;\n};\n\ntype ViewportProps = {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n};\n\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided width.\n *\n * > _Note: Only supports non-perspective mode._\n *\n * @param options fit bounds parameters\n * @returns - latitude, longitude and zoom\n */\nexport default function fitBounds(options: FitBoundsOptions): ViewportProps {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n    maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n    offset = [0, 0]\n  } = options;\n\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n\n  // width/height on the Web Mercator plane\n  const size = [\n    Math.max(Math.abs(se[0] - nw[0]), minExtent),\n    Math.max(Math.abs(se[1] - nw[1]), minExtent)\n  ];\n\n  const targetSize = [\n    width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n  ];\n\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n\n  assert(Number.isFinite(zoom));\n\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n\n// Helpers\nfunction getPaddingObject(padding: number | Padding = 0): Padding {\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n\n  // Make sure all the required properties are set\n  assert(\n    Number.isFinite(padding.top) &&\n      Number.isFinite(padding.bottom) &&\n      Number.isFinite(padding.left) &&\n      Number.isFinite(padding.right)\n  );\n\n  return padding;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}